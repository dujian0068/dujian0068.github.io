
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>ReentrantReadWriteLock源码分析及理解 | bmilk</title>
    <meta name="author" content="Du Jian" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar-link.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!--<script type="text/javascript" src="/js/highlight/highlight.js"></script>-->
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
 <link
     rel="stylesheet"
     href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/androidstudio.min.css"
 />
<!--<link-->
<!--    rel="stylesheet"-->
<!--    href="/css/highlight/androidstudio.css"-->
<!--/>-->
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING...</h2>
                    <p>起身休息一下吧，比如痛痛快快上个厕所什么的</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>BMILK</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;BMILK</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>ReentrantReadWriteLock源码分析及理解</h1>
    </div>
    <div class="info">
        
            <span class="date">
                <span class="icon">
                    <i class="fa-solid fa-calendar-days"></i>
                </span>
                2022/8/14
            </span>
        

        
        <span class="category">
            <a href="/categories/Java/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Java
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Java/" style="color: #03a9f4">
                    Java
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Lock/" style="color: #ffa2c4">
                    Lock
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%AE%80%E4%BB%8B">读写锁简介</a><ul>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7">读写锁的特性</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89">读写锁的定义</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5%E5%8F%8ASync%E5%90%8C%E6%AD%A5%E5%99%A8">公平策略及Sync同步器</a><ul>
<li><a href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5">非公平策略</a></li>
<li><a href="#%E5%85%AC%E5%B9%B3%E7%AD%96%E7%95%A5">公平策略</a></li>
<li><a href="#Sync%E5%90%8C%E6%AD%A5%E5%99%A8">Sync同步器</a></li>
</ul>
</li>
<li><a href="#%E8%AF%BB%E9%94%81">读锁</a><ul>
<li><a href="#%E8%AF%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89">读锁的定义</a></li>
<li><a href="#%E8%AF%BB%E9%94%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">读锁中的一些方法</a></li>
<li><a href="#%E8%AF%BB%E9%94%81%E5%8A%A0%E9%94%81">读锁加锁</a></li>
<li><a href="#%E8%AF%BB%E9%94%81%E8%A7%A3%E9%94%81">读锁解锁</a></li>
</ul>
</li>
<li><a href="#%E5%86%99%E9%94%81">写锁</a><ul>
<li><a href="#%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89">写锁的定义</a></li>
<li><a href="#%E5%86%99%E9%94%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">写锁的一些方法</a></li>
<li><a href="#%E5%86%99%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81">写锁的加锁</a></li>
<li><a href="#%E5%86%99%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE">写锁的释放</a></li>
</ul>
</li>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">读写锁的一些其他方法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="读写锁简介"><a href="#读写锁简介" class="headerlink" title="读写锁简介"></a>读写锁简介</h2><p>在之前的文章提到了可重入锁，这是一种排他锁，核心原理是同一时间只允许一个线程访问。除了排他锁还有一种共享锁，这种锁在同一时间支持多线程同时访问，<br>将排他锁和共享锁进行组合便有了读写锁。读写锁维护了一组锁——读锁和写锁。读锁在同一时间可以有多个线程共同访问，是一个共享锁；而写锁在同一时间仅支持<br>一个线程访问，是一个排他锁。通过读锁的允许多个线程同时访问，使得并发性相比单纯的排他锁效率有很大的提升。</p>
<p>在读写锁中，需要保证写锁对于读锁的可见性，也就是说当写锁更改数据之后读锁需要能够立刻获知。假设有一组线程访问同一个缓存区，其中只有一个线程向其中写数据，<br>其他的线程都是读数据，这块区域大部分的时间都是用户的读操作，只有很少的时间是写操作，多个线程的读并不会相互影响，那么就可以使用读写锁，只需要保证写操作<br>之后，数据立刻对于其他的读操作可见即可。</p>
<p><font color="#FF3030">读写锁是一个锁，只是可以进行共享或者排他的两种操作模式。</font>读写锁是一个锁，只是可以进行共享或者排他的两种操作模式。</p>
<h4 id="读写锁的特性"><a href="#读写锁的特性" class="headerlink" title="读写锁的特性"></a>读写锁的特性</h4><p>一般情况下，读写锁的性能会优于排他锁，因为程序中大多数场景都是读取数据，很少一部分是写数据。在读取并发多的情况下，可以提供比排他锁更好的吞吐量。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公平性</td>
<td align="center">读写锁可以选择公平和非公平性两种特性，默认为非公平模式，并且吞吐量非公平由于公平模式</td>
</tr>
<tr>
<td align="center">可重入性</td>
<td align="center">读(写)锁支持线程的重入。当一个线程获取读(写)锁后，这个线程可以再次获取这个读(写)锁</td>
</tr>
<tr>
<td align="center">锁降级</td>
<td align="center">当一个线程获取写锁之后，可以获取读锁，在释放写锁完成锁降级过程</td>
</tr>
</tbody></table>
<h4 id="读写锁的定义"><a href="#读写锁的定义" class="headerlink" title="读写锁的定义"></a>读写锁的定义</h4><p><code>ReentrantReadWriteLock</code>简单分析，主要介绍类由哪些部分组成及每部分的作用，具体的实现后面按照内部类及提供主要操作细解</p>
<pre><code class="Java">public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123;
    private static final long serialVersionUID = -6992448646407690164L;
    /** Inner class providing readlock */
    //读锁，读锁类是读写锁的内部类
    private final ReentrantReadWriteLock.ReadLock readerLock;
    /** Inner class providing writelock */
    //写锁，写锁类是读写锁的内部类
    private final ReentrantReadWriteLock.WriteLock writerLock;
    /** Performs all synchronization mechanics */
    //同步器，完成核心的加锁释放锁的过程，公平机制委派其子类实现
    final Sync sync;

    /**
     * Creates a new &#123;@code ReentrantReadWriteLock&#125; with
     * default (nonfair) ordering properties.
     */
    //默认的读写锁构造函数，默认使用非公平模式
    public ReentrantReadWriteLock() &#123;
        this(false);
    &#125;

    /**
     * Creates a new &#123;@code ReentrantReadWriteLock&#125; with
     * the given fairness policy.
     *
     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy
     */
    //带公平策略选择的构造器，其中参数为true代表公平模式，false代表非公平模式
    public ReentrantReadWriteLock(boolean fair) &#123;
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    &#125;
    
    //获取写锁
    public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;

    //获取读锁
    public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;
    
    //同步器类，实现核心的加锁解锁同步队列的操作，委派子类实现公平非公平策略
    abstract static class Sync extends AbstractQueuedSynchronizer &#123;......&#125;

    //非公平模式同步器，继承Sync并实现非公平策略
    static final class NonfairSync extends Sync&#123;....&#125;

    //公平模式同步器，继承Sync并实现公平策略
    static final class FairSync extends Sync&#123;....&#125;

    //写锁类，使用与外部类一致的公平策略
    public static class WriteLock implements Lock, java.io.Serializable&#123;......&#125;

    //读锁类，使用与外部类一致的公平策略
    public static class ReadLock implements Lock, java.io.Serializable&#123;......&#125;
</code></pre>
<h2 id="公平策略及Sync同步器"><a href="#公平策略及Sync同步器" class="headerlink" title="公平策略及Sync同步器"></a>公平策略及Sync同步器</h2><p>读写锁提供了公平与非公平策略，并由<code>Sync</code>的子类实现。<code>NonfairSync</code>与<code>FairSync</code>主要用来判断获取读锁和写锁的时候是否需要阻塞，<br>其获取锁的过程全部交由<code>Sync</code>实现。也可以说使<code>Sync</code>分为公平与非公平两个版本。</p>
<h4 id="非公平策略"><a href="#非公平策略" class="headerlink" title="非公平策略"></a>非公平策略</h4><p>非公平版本的同步器，详细解释见源码注释</p>
<pre><code class="Java">//公平版本的同步器
static final class NonfairSync extends Sync &#123;
    private static final long serialVersionUID = -8159625535654395037L;
    //用于判断获取写锁的时，获取写锁的线程是否需要进入同步队列等待
    //写锁是一个排他锁，在非公平模式下永远不需要阻塞，同可重入锁
    final boolean writerShouldBlock() &#123;
        return false; // writers can always barge
    &#125;
    
    //用于判断获取读锁的时，获取读锁的线程是否需要进入同步队列等待
    //讲道理，在非公平模式下是可以抢占式的获取锁，但是由于读锁是一个共享锁，在一定范围内可以不阻塞获取读锁的线程，
    //后来的也可以获取，不需要关注队列中是否有线程等待。
    //而写锁是排他锁，在读锁被持有的情况下会需要等待，而此时源源不断的线程获取读锁，那么写锁将一直不能获取锁，
    //造成饥饿，因此需要进行饥饿避免。
    final boolean readerShouldBlock() &#123;
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        //避免写锁饥饿的策略，当队列中的头节点的后继节点是一个尝试获取写锁的节点
        //则使获取读锁的线程进入同步等待队列排队并阻塞
        return apparentlyFirstQueuedIsExclusive();
    &#125;
&#125;

//这个方法在AQS中实现，目的就是执行的操作就是判断队列的头节点的后继节点是不是获取写锁
final boolean apparentlyFirstQueuedIsExclusive() &#123;
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
&#125;
</code></pre>
<h4 id="公平策略"><a href="#公平策略" class="headerlink" title="公平策略"></a>公平策略</h4><p>公平版本的同步器，详细解释见源码注释</p>
<pre><code class="Java">//相比非公平版本就会简单很多，只需要判断队列中是否有现成在等待就可以
static final class FairSync extends Sync &#123;
        private static final long serialVersionUID = -2274990926593161451L;
        final boolean writerShouldBlock() &#123;
            return hasQueuedPredecessors();
        &#125;
        final boolean readerShouldBlock() &#123;
            return hasQueuedPredecessors();
        &#125;
    &#125;
</code></pre>
<h4 id="Sync同步器"><a href="#Sync同步器" class="headerlink" title="Sync同步器"></a>Sync同步器</h4><p><code>Sync</code>实现了主要的加锁解锁的操作。读写锁同样依赖<code>AQS</code>来实现同步功能，在AQS中由<code>State</code>整型字段代表所数量而这里是两种锁，因此使用位操作来代表不同的锁，<br>使用高16位代表共享锁(读锁)，低16位代表排他锁(写锁)如下图，并且所有与为操有关的事情都在这里完成，<code>AQS</code>中仅提供一些判断接口及队列操作。<br><img src="/2022/08/java/lock/ReentrantReadWriteLock/ReentrantReadWriteLock/%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81.png" alt="读写锁状态"><span class="image-caption">读写锁状态</span></p>
<p>具体代码解释见注释</p>
<pre><code class="Java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;
    private static final long serialVersionUID = 6317671515068378041L;

    /*
     * 读锁和写锁的一些常数和函数
     * 将锁状态在逻辑上分为两个无符号的短整型
     * 低位代表排他锁(写锁)的计数器
     * 高位代表共享锁(读锁)的计数器
     */

    //共享锁的偏移量——16位
    static final int SHARED_SHIFT   = 16;
    //共享锁计数器加一或者减一的基数
    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
    //锁计数器的最大值，做最大可以被同时或者重入获取的次数
    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
    //写锁的掩码 和锁状态state按位与操作可以得到写锁的计数器
    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;

    //计算共享锁的持有量(读锁)
    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;
    //计算排他锁的持有量(写锁)
    static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;

    /**
     * 每个线程持有的读锁的计数器.
     * 作为ThreadLocal维护; 最后一成功加锁的线程信息缓存在cachedHoldCounter
     */
    static final class HoldCounter &#123;
        //线程持有的读锁的数量
        int count = 0;
        // Use id, not reference, to avoid garbage retention
        //使用id而不使用引用避免垃圾保留
        final long tid = getThreadId(Thread.currentThread());
    &#125;

    /**
     * ThreadLocal 子类. 重写了initialValue方法，
     * 在第一次get时(之前也没进行过set操作)返回count值为0而不是null
     */
    static final class ThreadLocalHoldCounter
        extends ThreadLocal&lt;HoldCounter&gt; &#123;
        public HoldCounter initialValue() &#123;
            return new HoldCounter();
        &#125;
    &#125;

    /**
     * The number of reentrant read locks held by current thread.
     * Initialized only in constructor and readObject.
     * Removed whenever a thread&#39;s read hold count drops to 0.
     */
    //读锁被当前线程持有的次数，仅在构造函数和readObject中初始化
    //当线程的读锁持有数量为0时删除
    private transient ThreadLocalHoldCounter readHolds;

    /**
     * The hold count of the last thread to successfully acquire
     * readLock. This saves ThreadLocal lookup in the common case
     * where the next thread to release is the last one to
     * acquire. This is non-volatile since it is just used
     * as a heuristic, and would be great for threads to cache.
     *
     * &lt;p&gt;Can outlive the Thread for which it is caching the read
     * hold count, but avoids garbage retention by not retaining a
     * reference to the Thread.
     *
     * &lt;p&gt;Accessed via a benign data race; relies on the memory
     * model&#39;s final field and out-of-thin-air guarantees.
     */
    //最后一个成功获取读锁的线程持有的读锁的数量
    private transient HoldCounter cachedHoldCounter;

    /**
     * firstReader is the first thread to have acquired the read lock.
     * firstReaderHoldCount is firstReader&#39;s hold count.
     *
     * &lt;p&gt;More precisely, firstReader is the unique thread that last
     * changed the shared count from 0 to 1, and has not released the
     * read lock since then; null if there is no such thread.
     *
     * &lt;p&gt;Cannot cause garbage retention unless the thread terminated
     * without relinquishing its read locks, since tryReleaseShared
     * sets it to null.
     *
     * &lt;p&gt;Accessed via a benign data race; relies on the memory
     * model&#39;s out-of-thin-air guarantees for references.
     *
     * &lt;p&gt;This allows tracking of read holds for uncontended read
     * locks to be very cheap.
     */
    //最后一个将读锁计数器从0改为1的线程，并且一直没有释放读锁
    //如果不存在这个线程则为null
    private transient Thread firstReader = null;
    private transient int firstReaderHoldCount;

    //构造函数
    Sync() &#123;
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    &#125;

    /*
     * Acquires and releases use the same code for fair and
     * nonfair locks, but differ in whether/how they allow barging
     * when queues are non-empty.
     */

    /**
     * Returns true if the current thread, when trying to acquire
     * the read lock, and otherwise eligible to do so, should block
     * because of policy for overtaking other waiting threads.
     */
    //获取和释放读写锁，公平版本和非公平版本使用同样的代码结构
    //但在当前线程是否需要排队阻塞，如何阻塞方面存在差异
    //返回true表示当前线程试图获取读锁应当被阻塞，
    abstract boolean readerShouldBlock();

    /**
     * Returns true if the current thread, when trying to acquire
     * the write lock, and otherwise eligible to do so, should block
     * because of policy for overtaking other waiting threads.
     */
    //true表示当前线程尝试获取写锁应该被阻塞
    abstract boolean writerShouldBlock();

    /*
     * Note that tryRelease and tryAcquire can be called by
     * Conditions. So it is possible that their arguments contain
     * both read and write holds that are all released during a
     * condition wait and re-established in tryAcquire.
     */
    
    //releases：释放写锁的次数，该值小于等于当前线程持有的写锁的数量
    //返回这个线程是否继续持有这个写锁
    protected final boolean tryRelease(int releases) &#123;
        
        //判断当前线程是否持有这个排他锁
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        //计算释放之后持有这个锁的次数
        int nextc = getState() - releases;
        boolean free = exclusiveCount(nextc) == 0;
        //释放后不在持有这个写锁
        if (free)
            //设置锁属于的线程为null
            setExclusiveOwnerThread(null);
        //设置锁的状态
        setState(nextc);
        return free;
    &#125;

    //尝试获取写锁
    protected final boolean tryAcquire(int acquires) &#123;
        /*
         * Walkthrough:
         * 1. If read count nonzero or write count nonzero
         *    and owner is a different thread, fail.
         * 2. If count would saturate, fail. (This can only
         *    happen if count is already nonzero.)
         * 3. Otherwise, this thread is eligible for lock if
         *    it is either a reentrant acquire or
         *    queue policy allows it. If so, update state
         *    and set owner.
         */
        /*
         * 需要完成的工作:
         * 1. 如果锁状态(包含读锁和写锁)不为0，并且当前线程没有持有写锁则失败
         * 2. 如果写锁计数器大于最大值则获取失败
         * 3. 否则如果是重入的获取锁，则会被允许.
         */
        Thread current = Thread.currentThread();
        //获取锁状态
        int c = getState();
        //获取写锁的锁状态
        int w = exclusiveCount(c);
        //如果锁被不为null即可能被任何一个线程持有
        if (c != 0) &#123;
            // (Note: if c != 0 and w == 0 then shared count != 0)
            //w==0则读锁被某个线程持有或者写锁被其他线程持有则获取锁失败
            //进入队列排队
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;

            //写所已经被当前线程持有则判断再次加锁后是否会超过写锁的最大可以被加锁的次数
            //超过则加锁失败
            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            // Reentrant acquire
            //重入的获取锁
            setState(c + acquires);
            return true;
        &#125;
        //锁没有被任何线程持有，则需要根据公平策略来判断当前线程是否需要阻塞
        //公平锁：检查同步等待队列，若队列中存在等待时间更长的线程则需要阻塞
        //非公平锁：可以抢占式获取写锁，不需要阻塞

        //需要被阻塞或者CAs操作失败则进入同步队列
        if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
            return false;
        //不需要阻塞并且加锁成功，设置排他锁的所属线程信息
        setExclusiveOwnerThread(current);
        return true;
    &#125;

    //尝试释放共享锁，与加共享锁一致，只能一个一个的释放
    //unused参数没有被使用
    protected final boolean tryReleaseShared(int unused) &#123;
        Thread current = Thread.currentThread();
        //当前线程是firstReader并且仅持有一次读锁，在释放读锁后firstReader应该置null
        if (firstReader == current) &#123;
            // assert firstReaderHoldCount &gt; 0;
            if (firstReaderHoldCount == 1)
                firstReader = null;
            else
                firstReaderHoldCount--;
        &#125; else &#123;
            //获取当前线程的HoldCounter信息
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                rh = readHolds.get();
            int count = rh.count;
            //当读诵持有数量归零时，会从线程的threadLocals中删除readHolds
            if (count &lt;= 1) &#123;
                readHolds.remove();
                //没持有锁的县城不能释放锁
                if (count &lt;= 0)
                    throw unmatchedUnlockException();
            &#125;
            --rh.count;
        &#125;
        //使用cas操作原子的减少锁状态，避免CAS操作失败的情况
        for (;;) &#123;
            int c = getState();
            //减少一个读锁
            int nextc = c - SHARED_UNIT;
            if (compareAndSetState(c, nextc))
                // 释放读锁对于读操作没有影响,
                // 但是如果现在读锁和写锁都是空闲的
                // 可能会使等待的获取写锁的操作继续
                
                //返回锁是否还被任何一个线程持有
                return nextc == 0;
        &#125;
    &#125;

    private IllegalMonitorStateException unmatchedUnlockException() &#123;
        return new IllegalMonitorStateException(
            &quot;attempt to unlock read lock, not locked by current thread&quot;);
    &#125;

    //获取读锁
    //unused参数没有被使用，一个一个加锁
    protected final int tryAcquireShared(int unused) &#123;
        /*
         * Walkthrough:
         * 1. If write lock held by another thread, fail.
         * 2. Otherwise, this thread is eligible for
         *    lock wrt state, so ask if it should block
         *    because of queue policy. If not, try
         *    to grant by CASing state and updating count.
         *    Note that step does not check for reentrant
         *    acquires, which is postponed to full version
         *    to avoid having to check hold count in
         *    the more typical non-reentrant case.
         * 3. If step 2 fails either because thread
         *    apparently not eligible or CAS fails or count
         *    saturated, chain to version with full retry loop.
         */
        /*
         * 待办事项:
         * 1. 如果写锁被其他线程获取，则失败.
         * 2. 否则这个线程就有资格使用锁的状态，因此需要判断是否因为
         *    因为同步等待策略而阻塞，否则尝通过cas操作尝试授予锁
         *    可重入性的操作在fullTryAcquireShared中进行
         *    避免在不可重入的情况下检查锁状态
         * 3. 如果步骤2失败，因为线程不符合条件或者cas失败
         *    则进入fullTryAcquireShared中循环重试
         */
        Thread current = Thread.currentThread();
        int c = getState();
            //写锁被其他线程持有则获取读锁失败，需要进入同步等待队列
        if (exclusiveCount(c) != 0 &amp;&amp;
            getExclusiveOwnerThread() != current)
            return -1;
        int r = sharedCount(c);
            
            /**
             * 判断当前线程是否需要阻塞
             * 不同的公平策略有不同的判断方式
             * 非公平模式下，如果存在同步等待队列且第一个是尝试获取写锁的
             * 其他线程则需要阻塞
             * 公平模式下，队列中存在排队等待的线程则需要进入队列等待
             */
    
            //如果当前线程已经获取乐写锁，则这可以是一个锁降级的过程
            //不用进入队列排队
        if (!readerShouldBlock() &amp;&amp;
            //锁的获取次数不能超过最大的可获取的次数
            r &lt; MAX_COUNT &amp;&amp;
            //不需要阻塞，锁的计数没有超过最大值则尝试通过cas操作加锁
            //可能会失败，如果存在多个线程同时竞争
            compareAndSetState(c, c + SHARED_UNIT)) &#123;
            //加锁成功，判断是否是第一个加锁的线程，是则设置firstReader信息
            //firstReader信息将不会在threadLocals中保存
            if (r == 0) &#123;
                firstReader = current;
                firstReaderHoldCount = 1;
    
                //firstReader的重入情况
            &#125; else if (firstReader == current) &#123;
                firstReaderHoldCount++;
            &#125; else &#123;
                //当前线程是最后一个获取读锁的线程，
                //需要将当前线程设置为cachedHoldCounter
                HoldCounter rh = cachedHoldCounter;
                //当前线程不是在此之前最后一次获取读锁的线程
                //需要从ThreadLocals中获取当前锁的计数信息
                //并且将当前线程设置为最后一个获取读锁的线程
                if (rh == null || rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                //如果当前线程就是在此之前最后一次获取读锁的信息
                //并且锁计数器为0，则需要设置当前线程的threadLcoals中保存的锁计数信息
                //因为锁计数器为0的时候会从ThreadLocals中删除readHolds的信息
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            &#125;
            return 1;
        &#125;
        //需要被阻塞、锁计数器超过最大值、或者cas设置锁状态失败
        //进入完整版本的获取锁的过程
        return fullTryAcquireShared(current);
    &#125;

    /**
     * Full version of acquire for reads, that handles CAS misses
     * and reentrant reads not dealt with in tryAcquireShared.
     */
    final int fullTryAcquireShared(Thread current) &#123;
        /*
         * This code is in part redundant with that in
         * tryAcquireShared but is simpler overall by not
         * complicating tryAcquireShared with interactions between
         * retries and lazily reading hold counts.
         */
        HoldCounter rh = null;
        //死循环获取锁，获取锁的结果要么阻塞，要么获取成功
        for (;;) &#123;
            int c = getState();
                //写锁被获取
            if (exclusiveCount(c) != 0) &#123;
                    //写锁被其他线程获取则获取失败
                    //写锁被当前线程获取则可以直接获取读锁，在后面处理
                if (getExclusiveOwnerThread() != current)
                    return -1;
                //如果写锁被当前线程获取而因为尝试获取读锁阻塞，会造成死锁
                // else we hold the exclusive lock; blocking here
                // would cause deadlock.
                
                //写锁没有被获取并且存在同步等待队列
                //且第一个等待的节点是非当前线程的获取写锁的节点
            &#125; else if (readerShouldBlock()) &#123;
                // Make sure we&#39;re not acquiring read lock reentrantly
    
                //当前线程是firstReader再次获取读锁
                //firstReader变量存在的前提是获取读锁的线程没有被释放读锁
                //则是一种重入的情况，可以直接判断并增加锁计数器
                if (firstReader == current) &#123;
                    // assert firstReaderHoldCount &gt; 0;
                
                //当前线程不是firstReader
                &#125; else &#123;
                    if (rh == null) &#123;
                        //rh：当前线程对应的锁计数器信息
                        //在当前线程的threadLocals中存储
                        rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current)) &#123;
                            rh = readHolds.get();
                            //当前线程没有获取锁，从threadLocals中移除这个锁信息
                            //因为readHolds.get()从当前线程的threadLocals中获取HoldCounter对象时
                            //如果threadLocals中不存在当前锁的状态信息，get的时候会初始化一个，count=0
                            if (rh.count == 0)
                                readHolds.remove();
                        &#125;
                    &#125;
                    //当前线程不是重入的获取锁
                    //并且同步等待队列的第一个等待节点尝试获取写锁。且不失当前线程
                    //当前线程需要排队等待
                    //目的：避免写锁的无限及饥饿
                    //当前线程已经获取锁
                    if (rh.count == 0)
                        return -1;
                &#125;
            &#125;
            //可以获取读锁的情况：写锁被当前线程获取或者重入的获取锁
            //或者不用阻塞写锁也没有被其他线程获取，到这里的原因可能是tryAcquireShared中CAS操作失败
            //如果是当前线程已经获取乐写锁，则这是一个锁降级的过程
          
            //超过读锁计数器的最大值
            if (sharedCount(c) == MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
    
            //cas的获取锁，如果cas操作失会循环获取
            if (compareAndSetState(c, c + SHARED_UNIT)) &#123;
                //如果当前线程是将读锁从0-&gt;1,则是firstReader
                if (sharedCount(c) == 0) &#123;
                    firstReader = current;
                    firstReaderHoldCount = 1;
                //firstReader重入的获取锁
                &#125; else if (firstReader == current) &#123;
                    firstReaderHoldCount++;
    
                //其他重入的获取锁，或者满足不阻塞条件的第一次获取锁
                &#125; else &#123;
                    if (rh == null)
                        rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
    
                    //设置cachedHoldCounter
                    cachedHoldCounter = rh; // cache for release
                &#125;
                return 1;
            &#125;
        &#125;
    &#125;

    /**
     * Performs tryLock for write, enabling barging in both modes.
     * This is identical in effect to tryAcquire except for lack
     * of calls to writerShouldBlock.
     */
    final boolean tryWriteLock() &#123;
        Thread current = Thread.currentThread();
        int c = getState();
        if (c != 0) &#123;
            int w = exclusiveCount(c);
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;
            if (w == MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
        &#125;
        if (!compareAndSetState(c, c + 1))
            return false;
        setExclusiveOwnerThread(current);
        return true;
    &#125;

    /**
     * Performs tryLock for read, enabling barging in both modes.
     * This is identical in effect to tryAcquireShared except for
     * lack of calls to readerShouldBlock.
     */
    final boolean tryReadLock() &#123;
        Thread current = Thread.currentThread();
        for (;;) &#123;
            int c = getState();
            if (exclusiveCount(c) != 0 &amp;&amp;
                getExclusiveOwnerThread() != current)
                return false;
            int r = sharedCount(c);
            if (r == MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            if (compareAndSetState(c, c + SHARED_UNIT)) &#123;
                if (r == 0) &#123;
                    firstReader = current;
                    firstReaderHoldCount = 1;
                &#125; else if (firstReader == current) &#123;
                    firstReaderHoldCount++;
                &#125; else &#123;
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                &#125;
                return true;
            &#125;
        &#125;
    &#125;

    //返回当前线程是否持有写锁
    protected final boolean isHeldExclusively() &#123;
        // While we must in general read state before owner,
        // we don&#39;t need to do so to check if current thread is owner
        return getExclusiveOwnerThread() == Thread.currentThread();
    &#125;

    // Methods relayed to outer class
    //返回一个与锁关联的Condition
    final ConditionObject newCondition() &#123;
        return new ConditionObject();
    &#125;

    //获取持有写锁的线程
    final Thread getOwner() &#123;
        // Must read state before owner to ensure memory consistency
        return ((exclusiveCount(getState()) == 0) ?
                null :
                getExclusiveOwnerThread());
    &#125;
    
    //获取所有线程持有的总的读锁的数量
    final int getReadLockCount() &#123;
        return sharedCount(getState());
    &#125;

    final boolean isWriteLocked() &#123;
        return exclusiveCount(getState()) != 0;
    &#125;

    获取当前线程持有的写锁的数量
    final int getWriteHoldCount() &#123;
        return isHeldExclusively() ? exclusiveCount(getState()) : 0;
    &#125;

    //获取当前线程持有的读锁的数量
    final int getReadHoldCount() &#123;
        if (getReadLockCount() == 0)
            return 0;

        //如果当前线程是firstReader则直接返回
        Thread current = Thread.currentThread();
        if (firstReader == current)
            return firstReaderHoldCount;

        //如果当前线程是最后一个持有读锁的线程
        HoldCounter rh = cachedHoldCounter;
        if (rh != null &amp;&amp; rh.tid == getThreadId(current))
            return rh.count;

        //获取当前线程的HoldCounter中存储的持有锁的数量
        int count = readHolds.get().count;
        if (count == 0) readHolds.remove();
        return count;
    &#125;

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        s.defaultReadObject();
        readHolds = new ThreadLocalHoldCounter();
        setState(0); // reset to unlocked state
    &#125;

    final int getCount() &#123; return getState(); &#125;
&#125;
</code></pre>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁是一个支持重入的共享锁，只要没有超过锁计数器的范围，锁可以被任意多个线程获取。<br>锁状态为0且写锁没由被获取的情况下，读锁总能被获取，后续的获取操作也只是原子的增加锁计数器。<br>但是由于不同线程都持有锁，需要保存每个线程持有这个锁的次数，这就用到了<code>ThreadLocalHoldCounter</code>将线程的持有锁的次数保存在<br>现成的<code>threadLocals</code>字段中。</p>
<h4 id="读锁的定义"><a href="#读锁的定义" class="headerlink" title="读锁的定义"></a>读锁的定义</h4><p>读锁的定义很简单，读锁中也存在一个同步器，与外部类同步器保持一致，所有的操作交由同步器完成</p>
<pre><code class="Java">public static class ReadLock implements Lock, java.io.Serializable &#123;
    private static final long serialVersionUID = -5992448646407690164L;
    private final Sync sync;

    /**
     * Constructor for use by subclasses
     *
     * @param lock the outer lock object
     * @throws NullPointerException if the lock is null
     */
    protected ReadLock(ReentrantReadWriteLock lock) &#123;
        sync = lock.sync;
    &#125;
    ......
&#125;
</code></pre>
<h4 id="读锁中的一些方法"><a href="#读锁中的一些方法" class="headerlink" title="读锁中的一些方法"></a>读锁中的一些方法</h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock()</td>
<td align="center">尝试获取读锁，根据不同的公平策略，有不同的获取过程，忽略中断</td>
</tr>
<tr>
<td align="center">lockInterruptibly()</td>
<td align="center">同上，会响应中断，实现上是在获取锁和在队列中从阻塞唤醒后判断是否发生中断，若有则抛出中断异常</td>
</tr>
<tr>
<td align="center">tryLock()</td>
<td align="center">抢占式的尝试一次获取读锁，失败则返回不会进入同步等待队列</td>
</tr>
<tr>
<td align="center">tryLock(long timeout, TimeUnit unit)</td>
<td align="center">尝试获取读锁，会响应中断，同时具有超时功能，实现上是在<code>lockInterruptibly()</code>的基础上使用具有超时功能的<code>LockSupport.parkNanos(Object blocker, long nanos)</code></td>
</tr>
<tr>
<td align="center">unlock()</td>
<td align="center">释放一个获取的读锁</td>
</tr>
<tr>
<td align="center">newCondition()</td>
<td align="center">构造一个条件等待队列，在使用条件等待队列阻塞前，会释放所有的锁</td>
</tr>
</tbody></table>
<h4 id="读锁加锁"><a href="#读锁加锁" class="headerlink" title="读锁加锁"></a>读锁加锁</h4><pre><code class="Java">/**
 * Acquires the read lock.
 *
 * &lt;p&gt;Acquires the read lock if the write lock is not held by
 * another thread and returns immediately.
 *
 * &lt;p&gt;If the write lock is held by another thread then
 * the current thread becomes disabled for thread scheduling
 * purposes and lies dormant until the read lock has been acquired.
 */
//申请读锁
//如果写锁没有被其他线程持有，则立刻获得读锁并返回
//如果写锁没有被其他线程持有，处于线程调度的目的，当前线程会进入waiting状态直到获取到锁
public void lock() &#123;
    sync.acquireShared(1);
&#125;
</code></pre>
<p><code>acquireShared()</code>方法：至少会调用一次同步器的<code>tryAcquireShared()</code>方法</p>
<pre><code class="Java">/**
 * Acquires in shared mode, ignoring interrupts.  Implemented by
 * first invoking at least once &#123;@link #tryAcquireShared&#125;,
 * returning on success.  Otherwise the thread is queued, possibly
 * repeatedly blocking and unblocking, invoking &#123;@link
 * #tryAcquireShared&#125; until success.
 *
 * @param arg the acquire argument.  This value is conveyed to
 *        &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted
 *        and can represent anything you like.
 */
//以忽略中断、共享模式获取锁，至少会调用一次tryAcquireShared方法，成功获取锁则返回1，
//失败则返回-1，线程会进入同步等待队列，满足条件时会被阻塞直到前一个线程（写锁）释放或者(读锁)被获取
public final void acquireShared(int arg) &#123;
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
&#125;
//tryAcquireShared方法由同步器重写获取过程，是真正的获取锁的过程
//doAcquireShared中获取锁的步骤依然是交给tryAcquireShared完成，自身更多完成排队等待的动作
</code></pre>
<p><code>tryAcquireShared()</code>方法</p>
<pre><code class="Java">protected final int tryAcquireShared(int unused) &#123;
    /*
     * 待办事项:
     * 1. 如果写锁被其他线程获取，则失败.
     * 2. 否则这个线程就有资格使用锁的状态，因此需要判断是否因为
     *    因为同步等待策略而阻塞，否则尝通过cas操作尝试授予锁
     *    可重入性的操作在fullTryAcquireShared中进行
     *    避免在不可重入的情况下检查锁状态
     * 3. 如果步骤2失败，因为线程不符合条件或者cas失败
     *    则进入fullTryAcquireShared中循环重试
     */
    Thread current = Thread.currentThread();
    int c = getState();
        //写锁被其他线程持有则获取读锁失败，需要进入同步等待队列
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
        
        /**
         * 判断当前线程是否需要阻塞
         * 不同的公平策略有不同的判断方式
         * 非公平模式下，如果存在同步等待队列且第一个是尝试获取写锁的
         * 其他线程则需要阻塞
         * 公平模式下，队列中存在排队等待的线程则需要进入队列等待
         */

        //如果当前线程已经获取乐写锁，则这可以是一个锁降级的过程
        //不用进入队列排队
    if (!readerShouldBlock() &amp;&amp;
        //锁的获取次数不能超过最大的可获取的次数
        r &lt; MAX_COUNT &amp;&amp;
        //不需要阻塞，锁的计数没有超过最大值则尝试通过cas操作加锁
        //可能会失败，如果存在多个线程同时竞争
        compareAndSetState(c, c + SHARED_UNIT)) &#123;
        //加锁成功，判断是否是第一个加锁的线程，是则设置firstReader信息
        //firstReader信息将不会在threadLocals中保存
        if (r == 0) &#123;
            firstReader = current;
            firstReaderHoldCount = 1;

            //firstReader的重入情况
        &#125; else if (firstReader == current) &#123;
            firstReaderHoldCount++;
        &#125; else &#123;
            //当前线程是最后一个获取读锁的线程，
            //需要将当前线程设置为cachedHoldCounter
            HoldCounter rh = cachedHoldCounter;
            //当前线程不是在此之前最后一次获取读锁的线程
            //需要从ThreadLocals中获取当前锁的计数信息
            //并且将当前线程设置为最后一个获取读锁的线程
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            //如果当前线程就是在此之前最后一次获取读锁的信息
            //并且锁计数器为0，则需要设置当前线程的threadLcoals中保存的锁计数信息
            //因为锁计数器为0的时候会从ThreadLocals中删除readHolds的信息
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        &#125;
        return 1;
    &#125;
    //需要被阻塞、锁计数器超过最大值、或者cas设置锁状态失败
    //进入完整版本的获取锁的过程
    return fullTryAcquireShared(current);
&#125;
</code></pre>
<p><code>fullTryAcquireShared()</code>方法</p>
<pre><code class="Java">/**
 * 获取读锁操作的完整版本，处理CAS遗漏和可重入读操作，
 * tryAcquireShared中没有处理
 */

final int fullTryAcquireShared(Thread current) &#123;
    /*
     * This code is in part redundant with that in
     * tryAcquireShared but is simpler overall by not
     * complicating tryAcquireShared with interactions between
     * retries and lazily reading hold counts.
     */
    HoldCounter rh = null;
    //死循环获取锁，获取锁的结果要么阻塞，要么获取成功
    for (;;) &#123;
        int c = getState();
            //写锁被获取
        if (exclusiveCount(c) != 0) &#123;
                //写锁被其他线程获取则获取失败
                //写锁被当前线程获取则可以直接获取读锁，在后面处理
            if (getExclusiveOwnerThread() != current)
                return -1;
            //如果写锁被当前线程获取而因为尝试获取读锁阻塞，会造成死锁
            // else we hold the exclusive lock; blocking here
            // would cause deadlock.
            
            //写锁没有被获取并且存在同步等待队列
            //且第一个等待的节点是非当前线程的获取写锁的节点
        &#125; else if (readerShouldBlock()) &#123;
            // Make sure we&#39;re not acquiring read lock reentrantly

            //当前线程是firstReader再次获取读锁
            //firstReader变量存在的前提是获取读锁的线程没有被释放读锁
            //则是一种重入的情况，可以直接判断并增加锁计数器
            if (firstReader == current) &#123;
                // assert firstReaderHoldCount &gt; 0;
            
            //当前线程不是firstReader
            &#125; else &#123;
                if (rh == null) &#123;
                    //rh：当前线程对应的锁计数器信息
                    //在当前线程的threadLocals中存储
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) &#123;
                        rh = readHolds.get();
                        //当前线程没有获取锁，从threadLocals中移除这个锁信息
                        //因为readHolds.get()从当前线程的threadLocals中获取HoldCounter对象时
                        //如果threadLocals中不存在当前锁的状态信息，get的时候会初始化一个，count=0
                        if (rh.count == 0)
                            readHolds.remove();
                    &#125;
                &#125;
                //当前线程不是重入的获取锁
                //并且同步等待队列的第一个等待节点尝试获取写锁。且不失当前线程
                //当前线程需要排队等待
                //目的：避免写锁的无限及饥饿
                //当前线程已经获取锁
                if (rh.count == 0)
                    return -1;
            &#125;
        &#125;
        //可以获取读锁的情况：写锁被当前线程获取或者重入的获取锁
        //或者不用阻塞写锁也没有被其他线程获取，到这里的原因可能是tryAcquireShared中CAS操作失败
        //如果是当前线程已经获取乐写锁，则这是一个锁降级的过程
      
        //超过读锁计数器的最大值
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);

        //cas的获取锁，如果cas操作失会循环获取
        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;
            //如果当前线程是将读锁从0-&gt;1,则是firstReader
            if (sharedCount(c) == 0) &#123;
                firstReader = current;
                firstReaderHoldCount = 1;
            //firstReader重入的获取锁
            &#125; else if (firstReader == current) &#123;
                firstReaderHoldCount++;

            //其他重入的获取锁，或者满足不阻塞条件的第一次获取锁
            &#125; else &#123;
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;

                //设置cachedHoldCounter
                cachedHoldCounter = rh; // cache for release
            &#125;
            return 1;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="读锁解锁"><a href="#读锁解锁" class="headerlink" title="读锁解锁"></a>读锁解锁</h4><pre><code class="Java">/**
 * Attempts to release this lock.
 *
 * &lt;p&gt;If the number of readers is now zero then the lock
 * is made available for write lock attempts.
 */
//释放读锁
public void unlock() &#123;
    sync.releaseShared(1);
&#125;
</code></pre>
<p><code>releaseShared()</code>方法，在<code>AQS</code>中实现</p>
<pre><code class="Java">/**
 * Releases in shared mode.  Implemented by unblocking one or more
 * threads if &#123;@link #tryReleaseShared&#125; returns true.
 *
 * @param arg the release argument.  This value is conveyed to
 *        &#123;@link #tryReleaseShared&#125; but is otherwise uninterpreted
 *        and can represent anything you like.
 * @return the value returned from &#123;@link #tryReleaseShared&#125;
 */
//释放共享锁，
//这一步需要完成两个任务：1-释放当前线程的读锁，
//2-如果读锁不再被任何线程持有则唤醒同步等待队列中等待的节点(如果有)
//如果tryReleaseShared返回的是true，则解除同步等待队列中的一个或者多个阻塞的节点
//tryReleaseShared返回true代表读锁不再被任何线程持有
public final boolean releaseShared(int arg) &#123;
    if (tryReleaseShared(arg)) &#123;
        doReleaseShared();
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p><code>tryReleaseShared()</code>方法</p>
<pre><code class="Java">//尝试释放共享锁，与加共享锁一致，只能一个一个的释放
//unused参数没有被使用
protected final boolean tryReleaseShared(int unused) &#123;
    Thread current = Thread.currentThread();
    //当前线程是firstReader并且仅持有一次读锁，在释放读锁后firstReader应该置null
    if (firstReader == current) &#123;
        // assert firstReaderHoldCount &gt; 0;
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    &#125; else &#123;
        //获取当前线程的HoldCounter信息
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        //当读诵持有数量归零时，会从线程的threadLocals中删除readHolds
        if (count &lt;= 1) &#123;
            readHolds.remove();
            //没持有锁的县城不能释放锁
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        &#125;
        --rh.count;
    &#125;
    //使用cas操作原子的减少锁状态，避免CAS操作失败的情况
    for (;;) &#123;
        int c = getState();
        //减少一个读锁
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            // 释放读锁对于读操作没有影响,
            // 但是如果现在读锁和写锁都是空闲的
            // 可能会使等待的获取写锁的操作继续
            
            //返回锁是否还被任何一个线程持有
            return nextc == 0;
    &#125;
&#125;
</code></pre>
<p><code>doReleaseShared()</code>方法，在<code>AQS</code>中实现，用于唤醒队列中的后继节点，<br>这个方法的出口需要一些解释，具体内容参看<a href="doReleaseShared.md"><code>doReleaseShared()</code></a></p>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>写锁是一个支持重入的排他锁，队列的操作与可重入锁相同，可以作为参考，区别是获取锁的过程和进入队列的条件</p>
<h4 id="写锁的定义"><a href="#写锁的定义" class="headerlink" title="写锁的定义"></a>写锁的定义</h4><p>写锁的变脸与读锁相同，仅有一个同步器字段，所有的操作调用同步器对应的方法完成</p>
<pre><code class="Java">public static class WriteLock implements Lock, java.io.Serializable &#123;
    private static final long serialVersionUID = -4992448646407690164L;
    private final Sync sync;

    /**
     * Constructor for use by subclasses
     *
     * @param lock the outer lock object
     * @throws NullPointerException if the lock is null
     */
    protected WriteLock(ReentrantReadWriteLock lock) &#123;
        sync = lock.sync;
    &#125;
    .......
&#125;
</code></pre>
<h4 id="写锁的一些方法"><a href="#写锁的一些方法" class="headerlink" title="写锁的一些方法"></a>写锁的一些方法</h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock()</td>
<td align="center">尝试获取写锁，根据不同的公平策略，有不同的获取过程，忽略中断</td>
</tr>
<tr>
<td align="center">lockInterruptibly()</td>
<td align="center">同上，会响应中断，实现上是在获取锁和在队列中从阻塞唤醒后判断是否发生中断，若有则抛出中断异常</td>
</tr>
<tr>
<td align="center">tryLock()</td>
<td align="center">抢占式的尝试一次获取一次写锁，失败则返回不会进入同步等待队列</td>
</tr>
<tr>
<td align="center">tryLock(long timeout, TimeUnit unit)</td>
<td align="center">尝试获取写锁，会响应中断，同时具有超时功能，实现上是在<code>lockInterruptibly()</code>的基础上使用具有超时功能的<code>LockSupport.parkNanos(Object blocker, long nanos)</code></td>
</tr>
<tr>
<td align="center">unlock()</td>
<td align="center">释放一个获取的写锁</td>
</tr>
<tr>
<td align="center">newCondition()</td>
<td align="center">构造一个条件等待队列，在使用条件等待队列阻塞前，会释放所有的锁</td>
</tr>
<tr>
<td align="center">isHeldByCurrentThread()</td>
<td align="center">判断当前线程是否持有写锁</td>
</tr>
<tr>
<td align="center">getHoldCount</td>
<td align="center">获取当前线程重入性获取当前锁的次数</td>
</tr>
</tbody></table>
<h4 id="写锁的加锁"><a href="#写锁的加锁" class="headerlink" title="写锁的加锁"></a>写锁的加锁</h4><p>写锁是一个排他锁，总体思路感觉可以说是可重入锁和读锁得结合，写锁获取成功时要求读锁没有被获取并且写锁没有被其他线程获取，<br>类似于可重入锁，一定是独占的。考虑到读写锁是一对锁，因此在加锁的时候肯定是需要判断读锁有没有被获取。<br>读写锁任意一个被其他线程获取，都将导致线程进入同步等待队列等候。</p>
<p><strong>加锁：</strong></p>
<pre><code class="Java">/**
 * Acquires the write lock.
 *
 * &lt;p&gt;Acquires the write lock if neither the read nor write lock
 * are held by another thread
 * and returns immediately, setting the write lock hold count to
 * one.
 *
 * &lt;p&gt;If the current thread already holds the write lock then the
 * hold count is incremented by one and the method returns
 * immediately.
 *
 * &lt;p&gt;If the lock is held by another thread then the current
 * thread becomes disabled for thread scheduling purposes and
 * lies dormant until the write lock has been acquired, at which
 * time the write lock hold count is set to one.
 */
//尝试获取写锁，如果读锁和写锁都没有被其他线程持有，则可以获取写锁。
//如果当前线程已经获取了写锁，则锁计数器加一并返回
//如果锁由其他线程持有，那么线程将入同步等待队列阻塞，直到可以获取锁
public void lock() &#123;
    sync.acquire(1);
&#125;
</code></pre>
<p><code>acquire()</code>方法，在<code>AQS</code>中实现，这个就和可重入锁的一样了，由<code>AQS</code>完成队列的操作</p>
<pre><code class="Java">/**
 * Acquires in exclusive mode, ignoring interrupts.  Implemented
 * by invoking at least once &#123;@link #tryAcquire&#125;,
 * returning on success.  Otherwise the thread is queued, possibly
 * repeatedly blocking and unblocking, invoking &#123;@link
 * #tryAcquire&#125; until success.  This method can be used
 * to implement method &#123;@link Lock#lock&#125;.
 *
 * @param arg the acquire argument.  This value is conveyed to
 *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and
 *        can represent anything you like.
 */
public final void acquire(int arg) &#123;
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
&#125;
</code></pre>
<p><code>tryAcquire()</code>方法,实际获取写锁的方法，这份方法在<code>Sync</code>中实现，这里需要解释一个问题：</p>
<ul>
<li>在获取写锁的时候，若之前已经获取了读锁，则一定要释放读锁再获取读锁。如果不释放读锁，则可能造成死锁。<br>举个例子：假设有ABCD四个线程获取了读锁且没释放，此时线程A尝试获取写锁。由于读锁被线程获取，线程A将进入同步等待队列被阻塞，<br>此时线程A读锁依然没有被释放，读锁释放时唤醒后继节点的条件是读锁不被任何线程获取，此时读锁依然被A持有，且A在阻塞。<br>由于线程A在同步等待队列的队头且获取写锁，则之后所有的获取锁的线程都将被阻塞。至此死锁。</li>
</ul>
<pre><code class="Java">//尝试获取写锁
protected final boolean tryAcquire(int acquires) &#123;
    /*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */
    /*
     * 需要完成的工作:
     * 1. 如果锁状态(包含读锁和写锁)不为0，并且当前线程没有持有写锁则失败
     * 2. 如果写锁计数器大于最大值则获取失败
     * 3. 否则如果是重入的获取锁，则会被允许.
     */
    Thread current = Thread.currentThread();
    //获取锁状态
    int c = getState();
    //获取写锁的锁状态
    int w = exclusiveCount(c);
    //如果锁被不为null即可能被任何一个线程持有
    if (c != 0) &#123;
        // (Note: if c != 0 and w == 0 then shared count != 0)
        //w==0则读锁被某个线程持有或者写锁被其他线程持有则获取锁失败
        //进入队列排队
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;

        //写所已经被当前线程持有则判断再次加锁后是否会超过写锁的最大可以被加锁的次数
        //超过则加锁失败
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        //重入的获取锁
        setState(c + acquires);
        return true;
    &#125;
    //锁没有被任何线程持有，则需要根据公平策略来判断当前线程是否需要阻塞
    //公平锁：检查同步等待队列，若队列中存在等待时间更长的线程则需要阻塞
    //非公平锁：可以抢占式获取写锁，不需要阻塞

    //需要被阻塞或者CAs操作失败则进入同步队列
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    //不需要阻塞并且加锁成功，设置排他锁的所属线程信息
    setExclusiveOwnerThread(current);
    return true;
&#125;
</code></pre>
<p><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code>与可重入锁完全相同，<a target="_blank" rel="noopener" href="https://blog.bmilk.net/2022/08/java/lock/ReentrantLock/ReentrantLock%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">可以参考这里</a></p>
<h4 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h4><p>写锁的释放相对读锁来说复杂一些，读锁释放只需要唤醒等待队列中的写锁，并且只唤醒一个， 但是写锁释时，如果紧接着的都是读锁请求，那么就需要唤醒所有的读锁请求，因为读锁时共享锁， 所有的读锁请求可以同时被满足。</p>
<p>详细内容请<a target="_blank" rel="noopener" href="https://blog.bmilk.net/2022/08/java/lock/ReentrantReadWriteLock/%E5%86%99%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE/">参考这里</a></p>
<h2 id="读写锁的一些其他方法"><a href="#读写锁的一些其他方法" class="headerlink" title="读写锁的一些其他方法"></a>读写锁的一些其他方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isFair()</td>
<td align="center">判断锁是否使用的是公平模式</td>
</tr>
<tr>
<td align="center">getOwner()</td>
<td align="center">获取持有写锁的线程</td>
</tr>
<tr>
<td align="center">getReadLockCount()</td>
<td align="center">获取读锁被所有线程持有的次数</td>
</tr>
<tr>
<td align="center">isWriteLocked()</td>
<td align="center">判断写锁是否被任意一个线程获取</td>
</tr>
<tr>
<td align="center">isWriteLockedByCurrentThread()</td>
<td align="center">判断当前线程是否持有写锁</td>
</tr>
<tr>
<td align="center">getWriteHoldCount()</td>
<td align="center">获取当前线程重入的获取写锁的次数</td>
</tr>
<tr>
<td align="center">getReadHoldCount()</td>
<td align="center">获取当前线程重入的获取读锁的次数</td>
</tr>
<tr>
<td align="center">getQueuedWriterThreads()</td>
<td align="center">获取在同步等待队列中等待的获取写锁的线程集合</td>
</tr>
<tr>
<td align="center">getQueuedReaderThreads()</td>
<td align="center">获取在同步等待队列中等待的获取读锁的线程集合</td>
</tr>
<tr>
<td align="center">hasQueuedThreads()</td>
<td align="center">判断同步等待队列中是否存在节点(等待的线程)</td>
</tr>
<tr>
<td align="center">hasQueuedThread(Thread thread)</td>
<td align="center">判断给定的线程是否在队列中</td>
</tr>
<tr>
<td align="center">getQueueLength()</td>
<td align="center">获取同步等待队列中等待的节点个数</td>
</tr>
<tr>
<td align="center">getQueuedThreads()</td>
<td align="center">获取在同步等待队列中等待的线程集合</td>
</tr>
<tr>
<td align="center">hasWaiters(Condition condition)</td>
<td align="center">判断给定的条件等待队列中是否存在等待的节点</td>
</tr>
<tr>
<td align="center">getWaitQueueLength(Condition condition)</td>
<td align="center">判断给定的条件等待队列中是否存在等待的节点个数</td>
</tr>
<tr>
<td align="center">getWaitingThreads(Condition condition)</td>
<td align="center">获取给定的条件等待队列中是否存在等待的节点集合</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>读写锁把对对象的操作划分为读操作和写操作，读操作通过获取读锁只能读取对象，写操作通过获取写锁<br>来完成写操作的排他性。这种锁相对于排他锁而言具有更高的并发性。</li>
<li>已经获取写锁的线程可以通过锁降级来获取读锁</li>
<li>读写锁是一个锁，只是可以进行共享或者排他的两种操作模式。</li>
<li>如果一个锁既没有加写锁，也没有加读锁，队列中不存在等待的线程，则可以被任意一个线程获取任意一个锁</li>
<li>一个锁被加了读锁，则不能有任何线程加写锁</li>
<li>一个锁被加了写锁，加写锁的线程可以再次加读锁</li>
<li>非公平模式下，同步队列的第一个等待节点是获取写锁，则之后的获取读锁的线程需要等待</li>
<li>公平模式下，只要队列中存在等待的节点就需要进入队列等待</li>
<li>读写锁不支持锁升级</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.bmilk.net/2022/08/java/lock/ReentrantReadWriteLock/ReentrantReadWriteLockCode/">附ReentrantReadWriteLock全部源码理解</a></p>
<p><font color="#FF3030">转载请标明出处</font></p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 bmilk
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Du Jian
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="dujian0068/blog"
    data-repo-id="R_kgDOGryLBA"
    data-category="Announcements"
    data-category-id="DIC_kwDOGryLBM4ChDAf"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
